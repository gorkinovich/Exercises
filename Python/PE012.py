"""
| **Problem 12:** Highly divisible triangular number
| URL: https://projecteuler.net/problem=12
::

    The sequence of triangle numbers is generated by adding the
    natural numbers. So the 7th triangle number would be
    1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

    We can see that 28 is the first triangle number to have over
    five divisors.

    What is the value of the first triangle number to have over
    five hundred divisors?
|
:author: Gorka Suárez García
:copyright: (c) 2022, Gorka Suárez García
"""
from shared import is_multiple, PrimesGenerator

######################################################################
# Constants
######################################################################

GOAL = 500


######################################################################
# Functions
######################################################################

def triangle_numbers_generator():
    """
    This generator returns a sequence of triangle numbers.
    :return: The triangle numbers generator.
    """
    result = 0
    number = 1
    while True:
        result += number
        number += 1
        yield result


def get_factors(victim):
    """
    Gets the factors of a number.
    :param victim: The number to check.
    :return: A list with the divisors.
    """
    result = []
    for prime in PrimesGenerator():
        if victim < prime:
            return result
        elif prime == 1:
            result.append(prime)
        else:
            while is_multiple(victim, prime):
                result.append(prime)
                victim //= prime
    return result


def group_items_lineal(victims):
    """
    Groups the items inside a sequence in a lineal way. This function
    groups the elements only if they're neighbours, otherwise the
    result will have repeated groups of the same kind of element.
    :param victims: The sequence to group.
    :return: The list with the groups.
    """
    result = []
    current = []
    candidate = None
    # Check each element in the given sequence:
    for victim in victims:
        # When the candidate changes, add the current group,
        # set the new group and update the candidate:
        if candidate != victim:
            candidate = victim
            if current:
                result.append(current)
            current = [victim]
        # Otherwise, add the element to the current group:
        else:
            current.append(victim)
    # Add the final group and return the result:
    if current:
        result.append(current)
    return result


def calc_number_of_divisors(number):
    """
    Gets the number of divisors for a natural number. The trick of
    this algorithm is to calculate first the factors of the number,
    then we'll group the factors in a list of lists, to know the
    number of times a factor exists inside the list of factors.
    With this data structure, the formula to obtain the number of
    divisors is f(n) = f(n-1) * len(G(n)) + f(n-1), where G is
    the list with the groups of factors and f(0) = 1.
    :param number: The number to check.
    :return: The number of divisors.
    """
    result = 1
    factors = get_factors(number)
    groups = group_items_lineal(factors[1:])
    for size in [len(group) for group in groups]:
        result += result * size
    return result


def find_triangle_number(goal):
    """
    Find a triangle number to have over a goal of divisors.
    :param goal: The goal number to surpass.
    :return: The first number to surpass the goal.
    """
    for number in triangle_numbers_generator():
        if calc_number_of_divisors(number) > goal:
            return number


def main():
    """
    Main entry for the problem solver.
    """
    result = find_triangle_number(GOAL)

    # Show the final result of the problem:
    print(f"The first triangle number to have over {GOAL} divisors is {result}.")


######################################################################
# Functions (Slow version)
######################################################################

def get_divisors(victim):
    """
    Gets the divisors of a number.
    :param victim: The number to check.
    :return: A list with the divisors.
    """
    result = [1]
    if victim > 1:
        for current in range(2, victim):
            if is_multiple(victim, current):
                result.append(current)
        result.append(victim)
    return result


def find_triangle_number_slow(goal):
    """
    Find a triangle number to have over a goal of divisors.
    :param goal: The goal number to surpass.
    :return: The first number to surpass the goal.
    """
    for number in triangle_numbers_generator():
        divisors = get_divisors(number)
        if len(divisors) > goal:
            return number


######################################################################
# Module execution
######################################################################

if __name__ == "__main__":
    main()


######################################################################
# Test Functions
######################################################################

def test(limit=10_000, show_info=False):
    for number in range(1, limit):
        divisors = get_divisors(number)
        num_divs = calc_number_of_divisors(number)
        len_divs = len(divisors)
        if num_divs != len_divs:
            print(f"{number} -> {num_divs == len_divs} ({num_divs}, {len_divs})")
            if show_info:
                print(f">>> {len_divs} => {divisors}")
                factors = get_factors(number)
                print(f">>> {len(factors)} => {factors}")
                groups = group_items_lineal(factors)
                print(f">>> {len(groups)} => {groups}")
        else:
            print(f"{100 * number / limit}", end="\r")
    print("\nOK")
